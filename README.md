# CSRFとは
ユーザーがログイン済みの状態で、攻撃者のサイトから意図しないリクエストが送られてしまうという脆弱性。

# 攻撃者目線

# 対策の心得


# CSRF対策具体例（Spring Boot + Spring Security）
## (1) CSRFトークンをセッションに紐づけ（SpringSecurityではデフォルトでON）
POSTリクエストフォームにCSRFトークンを紐づけ
<img width="795" height="197" alt="スクリーンショット (16)" src="https://github.com/user-attachments/assets/c40e6b96-dfd6-4130-b4b4-09428dc024ea" />
SpringSecurityではCSRF対策がデフォルトでオンになっている
そのためPOSTリクエストには上記のCSRFトークンを紐づけする必要がある。
結果としてトークンを知らない他のサイトからのPOSTリクエストを防げる。

※CSRFトークンはPOSTリクエストのみに紐づけされる
- 対策しないとGETに対してCSRFが通ってしまう

※CSRFトークンだけでは不十分なケース
- GETリクエストにはCSRFトークンが使われない（副作用があるGETは避けるべき）
- CORS設定が甘いと、外部サイトからのリクエストが通ってしまうこともある
- セッション固定攻撃（Session Fixation）など、他の脆弱性と組み合わされると突破される可能性もある

## (2) SameSite Cookie属性の設定
これが最も効果的です。クロスサイトからのリクエストに対して、Cookieを送らせないようにできます。

## (3) Referer / Origin ヘッダーの検証
サーバー側で、リクエスト元が自分のドメインかどうかをチェックする方法。

## (4) GETで機密情報を返さない設計
表示系でも、機密情報はPOSTで取得する設計にする
もしくは、追加認証（パスワード再入力や2FA）を要求する

## (4) ログイン後のページ遷移にCSRFトークンを使わない代わりに、セッション内でアクセス制御
セッションに「直前のページ情報」や「ナビゲーション履歴」を持たせて、不自然な遷移を検知する
SPAなら、JavaScriptでナビゲーションを制御し、外部からの直接アクセスを防ぐ

※XSSでクッキーが盗まれると、SameSite=Strictはそもそも無意味になるためクッキーが盗まれないための脆弱性対策と連携が必須
